\documentclass[12pt]{article}
\usepackage[top=1in,bottom=1in,left=1in,right=1in]{geometry}
\usepackage{alltt}
\usepackage{array}	
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{verbatim}
\usepackage{setspace}
\usepackage{listings}
\usepackage{amssymb,amsmath, amsthm}

\title{SOEN 331: Introduction to Formal Methods\\for Software Engineering\\
Assignment 4 on Algebraic Specifications}
\author{\begin{tabular}{c}
Alec Adub (40032876) - \texttt{adub.alec@gmail.com} \tabularnewline
Alex Frappier Lachapelle (40019133) - \texttt{alexfl1024@gmail.com} \tabularnewline
Robert Nittolo (40032587) - \texttt{nittolorobert@yahoo.com} \tabularnewline
Pierre-Olivier Trottier (40059235) - \texttt{po.trottier@gmail.com} \tabularnewline\\
\end{tabular}}
\date{\today}

\begin{document}
\begin{spacing}{1.5}

\maketitle

\newpage

\section*{Binary Search Tree}

\noindent \textbf{Spec}: Binary Search Tree;\\
\noindent \textbf{Sort}: BSTTreeTree;\\
\noindent \textbf{Imports}: Element, Number, Boolean, $\mathbb{N}_0$;\\
\noindent \textbf{Operations}:\\
\hspace*{5mm} create $\rightarrow$ BSTTreeTree;\\
\hspace*{5mm} add : BSTTreeTree $\times$ Number $\times$ Element $\rightarrow$ BSTTree;\\
\hspace*{5mm} update : BSTTree $\times$ Number $\times$ Element $\rightarrow$ BSTTree;\\
\hspace*{5mm} delete : BSTTree $\times$ Number $\rightarrow$ BSTTree;\\
\hspace*{5mm} containsKey :  BSTTree $\times$ Number $\rightarrow$ Boolean;\\
\hspace*{5mm} contains : BSTTree $\times$ Element $\rightarrow$ Boolean;\\
\hspace*{5mm} left : BSTTree $\times$ Number $\rightarrow$ BSTTree;\\
\hspace*{5mm} right : BSTTree $\times$ Number $\rightarrow$ BSTTree;\\
\hspace*{5mm} parent : BSTTree $\times$ Number $\rightarrow$ Number;\\
\hspace*{5mm} isLeaf : BSTTree $\times$ Number $\rightarrow$ Boolean;\\
\hspace*{5mm} rootKey : BSTTree $\rightarrow$ Number;\\
\hspace*{5mm} isEmpty : BSTTree $\rightarrow$ Boolean;\\
\hspace*{5mm} depth : BSTTree $\rightarrow$ $\mathbb{N}_0$;\\
\hspace*{5mm} nNodes : BSTTree $\rightarrow$ $\mathbb{N}_0$;\\
\hspace*{5mm} nLeaves : BSTTree $\rightarrow$ $\mathbb{N}_0$;\\
\noindent \textbf{Variables}:\\
\hspace*{5mm} bst: Binary Search Tree; e: Element; n: Number\\
\noindent \textbf{Axioms}:\\
\hspace*{5mm} [A1] isEmpty(create) = true;\\
\hspace*{5mm} [A2] nNodes(create) = 0;\\
\hspace*{5mm} [A3] rootKey(create) = undefined;\\
\hspace*{5mm} [A4] depth(create) = 0;\\
\hspace*{5mm} [A5] left(create, n) = undefined\\
\hspace*{5mm} [A6] depth(add(create, 1, e)) = 1\\
\hspace*{5mm} [A7] nNodes(add(create, 1, e)) = 1\\
\hspace*{5mm} [A8] add(add(create, 1, e), 1, e) = undefined\\
\hspace*{5mm} [A9] depth(bst) $\leq$ nNodes(bst)\\

\section*{Binary Search Tree (Aditional Questions)}

\begin{enumerate}

\item How do you define a $deleteAll$ method that deletes all the keys and elements of a given BSTree? Formally specify it.\\
\textbf{deleteAll : BSTTree $\rightarrow$ BSTTree; \\ \textit{Where the Binary Tree returned is empty.}}

\item How do you define a $getAllKeys$ method that finds all keys within the BST that have a specific associated value? Formally specify it.\\
\textbf{getAllKeys : BSTTree $\times$ Element $\rightarrow$ Array; \\ \textit{Where the array contains all the retreived keys.}}

\item Define axioms that verify the clause "$isLeaf(BSTree, Number)$ takes a binary search tree and returns true if the node, whose key is specified by the number is a leaf, otherwise it returns false".\\
\hspace*{5mm} \textbf{[A1] isLeaf(add(create, 1, e), 1) = true}\\
\hspace*{5mm} \textbf{[A2] isLeaf(add(add(create, 1, e), 2, e), 1) = false}

\item Define an axiom that verifies the clause "$rootKey(BSTree)$ takes a binary search tree and returns the key that is stored in the root of the tree".\\
\hspace*{5mm} \textbf{[A] rootKey(add(create, 1, e)) = 1}\\

\item Define axiom(s) that verify the functionality of the $left(BSTree, Number)$ method for the cases: "if the left subtree does not exists, the method returns an empty tree".\\

\item Define an axiom that verifies a correct key is returned by $parent(BSTree, Number)$.\\

\end{enumerate}

\newpage

\section*{AVL Tree}

\noindent \textbf{Spec}: AVL Tree;\\
\noindent \textbf{Sort}: AVLTree;\\
\noindent \textbf{extend} BSTTree by\\
\noindent \textbf{Description}:\\Declaration of an AVL tree, which is simply put, a balanced Binary Tree.\\
\noindent \textbf{Operations}:\\
\hspace*{5mm} create $\rightarrow$ AVLTree;\\
\hspace*{5mm} add : AVLTree $\times$ Number $\times$ Element $\rightarrow$ AVLTree;\\
\hspace*{5mm} update : AVLTree $\times$ Number $\times$ Element $\rightarrow$ AVLTree;\\
\hspace*{5mm} delete : AVLTree $\times$ Number $\rightarrow$ AVLTree;\\
\hspace*{5mm} balanceFactor :  AVLTree $\rightarrow$ $\mathbb{N}_0$;\\
\hspace*{5mm} join : AVLTree $\times$ AVLTree $\rightarrow$ AVLTree;\\
\noindent \textbf{Variables}:\\
\hspace*{5mm} s: Set; x, y: Element;\\
\noindent \textbf{Axioms}:\\
\hspace*{5mm} [A1] isempty(newset) = true;\\
\hspace*{5mm} [A2] ismember(newset, x) = false;\\
\hspace*{5mm} [A3] ismember(add(s, x), x) = true;\\
\hspace*{5mm} [A4] add(add(s, x), y) = add(add(s, y), x);\\

\section*{AVL Tree (Aditional Questions)}

\begin{enumerate}

\item How do you define a method that verifies if a given tree is AVLTree?\\

\item Identify classes (categories) of all operations defined in your specification for AVLTree.\\

\end{enumerate}

\end{spacing}
\end{document}