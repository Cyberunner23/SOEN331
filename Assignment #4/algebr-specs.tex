\documentclass[12pt]{article}
\usepackage[top=1in,bottom=1in,left=1in,right=1in]{geometry}
\usepackage{alltt}
\usepackage{array}	
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{verbatim}
\usepackage{setspace}
\usepackage{listings}
\usepackage{amssymb,amsmath, amsthm}

\title{SOEN 331: Introduction to Formal Methods\\for Software Engineering\\
Assignment 4 on Algebraic Specifications}
\author{\begin{tabular}{c}
Alec Adub (40032876) - \texttt{adub.alec@gmail.com} \tabularnewline
Alex Frappier Lachapelle (40019133) - \texttt{alexfl1024@gmail.com} \tabularnewline
Robert Nittolo (40032587) - \texttt{nittolorobert@yahoo.com} \tabularnewline
Pierre-Olivier Trottier (40059235) - \texttt{po.trottier@gmail.com} \tabularnewline\\
\end{tabular}}
\date{\today}

\begin{document}
\begin{spacing}{1.5}

\maketitle

\newpage

\section*{Binary Search Tree}

\noindent \textbf{Spec}: Binary Search Tree;\\
\noindent \textbf{Sort}: BSTTreeTree;\\
\noindent \textbf{Imports}: Element, Number, Boolean, $\mathbb{N}_0$;\\
\noindent \textbf{Operations}:\\
\hspace*{5mm} create $\rightarrow$ BSTTreeTree;\\
\hspace*{5mm} add : BSTTreeTree $\times$ Number $\times$ Element $\rightarrow$ BSTTree;\\
\hspace*{5mm} update : BSTTree $\times$ Number $\times$ Element $\rightarrow$ BSTTree;\\
\hspace*{5mm} delete : BSTTree $\times$ Number $\rightarrow$ BSTTree;\\
\hspace*{5mm} containsKey :  BSTTree $\times$ Number $\rightarrow$ Boolean;\\
\hspace*{5mm} contains : BSTTree $\times$ Element $\rightarrow$ Boolean;\\
\hspace*{5mm} left : BSTTree $\times$ Number $\rightarrow$ BSTTree;\\
\hspace*{5mm} right : BSTTree $\times$ Number $\rightarrow$ BSTTree;\\
\hspace*{5mm} parent : BSTTree $\times$ Number $\rightarrow$ Number;\\
\hspace*{5mm} isLeaf : BSTTree $\times$ Number $\rightarrow$ Boolean;\\
\hspace*{5mm} rootKey : BSTTree $\rightarrow$ Number;\\
\hspace*{5mm} isEmpty : BSTTree $\rightarrow$ Boolean;\\
\hspace*{5mm} depth : BSTTree $\rightarrow$ $\mathbb{N}_0$;\\
\hspace*{5mm} nNodes : BSTTree $\rightarrow$ $\mathbb{N}_0$;\\
\hspace*{5mm} nLeaves : BSTTree $\rightarrow$ $\mathbb{N}_0$;\\
\noindent \textbf{Variables}:\\
\hspace*{5mm} bst: Binary Search Tree; e: Element; n: Number\\
\noindent \textbf{Axioms}:\\
\hspace*{5mm} [A1] isEmpty(create) = true;\\
\hspace*{5mm} [A2] nNodes(create) = 0;\\
\hspace*{5mm} [A3] rootKey(create) = undefined;\\
\hspace*{5mm} [A4] depth(create) = 0;\\
\hspace*{5mm} [A5] left(create, n) = undefined\\
\hspace*{5mm} [A6] depth(add(create, 1, e)) = 1\\
\hspace*{5mm} [A7] nNodes(add(create, 1, e)) = 1\\
\hspace*{5mm} [A8] add(add(create, 1, e), 1, e) = undefined\\
\hspace*{5mm} [A9] depth(bst) $\leq$ nNodes(bst)\\
\hspace*{5mm} [A10] depth(bst)  $>$ log(nNodes(bst))  if nNodes(bst)  $>$ 0  \\ 
\hspace*{5mm} [A11] depth(add(add(add(create(), 1, el1), 2, el2), 3, el3)) = 3\\
\hspace*{5mm} [A12] nNodes(add(add(add(create(), 1, el1), 2, el2), 3, el3)) = 3\\
\hspace*{5mm} [A13] rootKey((add(add(add(create(), 1, el1), 2, el2), 3, el3)) = 1\\
\hspace*{5mm} [A14] nNodes(right(add(add(add(create(), 1, el1), 2, el2), 3, el3)1)) = 2\\
\hspace*{5mm} [A15] nNodes(left(add(add(add(create(), 1, el1), 2, el2), 3, el3)3)) = 0\\
\section*{Binary Search Tree (Aditional Questions)}

\begin{enumerate}

\item How do you define a $deleteAll$ method that deletes all the keys and elements of a given BSTree? Formally specify it.\\
\textbf{deleteAll : BSTTree $\rightarrow$ BSTTree; \\ \textit{Where the Binary Tree returned is empty.}}

\item How do you define a $getAllKeys$ method that finds all keys within the BST that have a specific associated value? Formally specify it.\\
\textbf{getAllKeys : BSTTree $\times$ Element $\rightarrow$ Array; \\ \textit{Where the array contains all the retreived keys.}}

\item Define axioms that verify the clause "$isLeaf(BSTree, Number)$ takes a binary search tree and returns true if the node, whose key is specified by the number is a leaf, otherwise it returns false".\\
\hspace*{5mm} \textbf{[A1] isLeaf(add(create, 1, e), 1) = true}\\
\hspace*{5mm} \textbf{[A2] isLeaf(add(add(create, 1, e), 2, e), 1) = false}

\item Define an axiom that verifies the clause "$rootKey(BSTree)$ takes a binary search tree and returns the key that is stored in the root of the tree".\\
\hspace*{5mm} \textbf{[A] rootKey(add(create, 1, e)) = 1}\\

\item Define axiom(s) that verify the functionality of the $left(BSTree, Number)$ method for the cases: "if the left subtree does not exists, the method returns an empty tree".\\
\hspace*{5mm} \textbf{[A1] isEmpty(left(add(add(create, 1, e), 2, e), 3)) = isEmpty(create)}

\item Define an axiom that verifies a correct key is returned by $parent(BSTree, Number)$.\
\hspace*{5mm} \textbf{[A1] parent(add(add(create, 1, e), 2, e), 2) = 1}
\

\end{enumerate}

\newpage

\section*{AVL Tree}

\noindent \textbf{Spec}: AVL Tree;\\
\noindent \textbf{Sort}: AVLTree;\\
\noindent \textbf{extend} BSTTree by\\
\noindent \textbf{Description}:\\Declaration of an AVL tree, which is simply put, a balanced Binary Tree.\\
\noindent \textbf{Operations}:\\
\hspace*{5mm} create $\rightarrow$ AVLTree;\\
\hspace*{5mm} add : AVLTree $\times$ Number $\times$ Element $\rightarrow$ AVLTree;\\
\hspace*{5mm} update : AVLTree $\times$ Number $\times$ Element $\rightarrow$ AVLTree;\\
\hspace*{5mm} delete : AVLTree $\times$ Number $\rightarrow$ AVLTree;\\
\hspace*{5mm} balanceFactor :  AVLTree $\rightarrow$ $\mathbb{N}_0$;\\
\hspace*{5mm} join : AVLTree $\times$ AVLTree $\rightarrow$ AVLTree;\\
\noindent \textbf{Variables}:\\
\hspace*{5mm} tree: AVLTree; n: Number; elem: Element;\\
\noindent \textbf{Axioms}:\\

\hspace*{5mm}[A1] nNodes(tree) $<$= $2^{depth(tree)}$ -1;\\
\hspace*{5mm}[A2] balanceFactor(create)=0;\\
\hspace*{5mm} [A3]  balanceFactor(add(create(), n, elem)) = 1\\
\hspace*{5mm} [A4]  balanceFactor(add(add(create(), n, elem), n, elem)) = 1 \textbf{or} -1\\
\hspace*{5mm} [A5]  balanceFactor(tree, n, elem)) = 1 \textbf{or} -1 \textbf{or} 0\\
\hspace*{5mm} [A6]  depth(add(add(add(create(), 1, el1), 2, el2), 3, el3)) = 2\\
\hspace*{5mm} [A7] nNodes(add(add(add(create(), 1, el1), 2, el2), 3, el3)) = 3\\
\hspace*{5mm} [A8] balanceFactor(add(add(add(create(), 1, el1), 2, el2), 3, el3)) = 0 \\
\hspace*{5mm} [A9] rootKey(add(add(add(create(), 1, el1), 2, el2), 3, el3)) = 2\\
\hspace*{5mm} [A10] nNodes(left(add(add(add(create(), 1, el1), 2, el2), 3, el3))) = 1 \textbf{and}  nNodes(right( add(add(add(create(), 1, el1), 2, el2), 3, el3))) = 1\\

\section*{AVL Tree (Aditional Questions)}

\begin{enumerate}

\item How do you define a method that verifies if a given tree is AVLTree?\\
\textbf{isAVLTree : BSTree $\rightarrow$ Boolean} \\ \\
\textbf{Check if the balance factor is -1, 0 or 1. Then, visit each node in the tree and verify that the right child node has a higher value then its own value, as well as verify that the left child node has a smaller value than it own value. Providing that the node has children in the first place.}
  


\item Identify classes (categories) of all operations defined in your specification for AVLTree.\\
\textbf{Primitive Constructors:} \\
create\\
\textbf{Non-Primitive Constructors:} \\
join \\
\textbf{Mutators:} \\
add \\
update \\
delete \\
\textbf{Observers:} \\
balanceFactor \\
containsKey \\
contains\\
left\\
right\\
parent\\
isLeaf\\
rootKey\\
isEmpty\\
depth\\
nNodes\\
nLeaves\\


\end{enumerate}

\end{spacing}
\end{document}